"""
Enhanced Chat Assistant - S·ª≠ d·ª•ng Scan Orchestrator m·ªõi
"""

import json
import os
import re
import time
import asyncio
import requests
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
from app.clients.gemini_client import GeminiClient
from app.core.enhanced_rag_retriever import EnhancedRAGRetriever
from app.core.scan_orchestrator import ScanOrchestrator
from app.core.evidence_storage import EvidenceStorage

class ChatCommand(Enum):
    """C√°c l·ªánh chat"""
    PAYLOAD = "/payload"
    SCAN = "/scan"
    SCAN_STATUS = "/scan-status"
    SCAN_RESULTS = "/scan-results"
    SCAN_CANCEL = "/scan-cancel"
    HELP = "/help"
    REPORT = "/report"
    RECOMMEND = "/recommend"
    EVIDENCE = "/evidence"
    GREETING = "/"
    UNKNOWN = "unknown"

class VulnerabilityType(Enum):
    """C√°c lo·∫°i l·ªó h·ªïng"""
    XSS = "xss"
    SQL_INJECTION = "sql_injection"
    MISCONFIGURATION = "misconfiguration"
    IDOR = "idor"

@dataclass
class ChatResponse:
    """Response c·ªßa chat assistant"""
    message: str
    command: ChatCommand
    vulnerability_type: Optional[VulnerabilityType] = None
    target_url: Optional[str] = None
    payloads: Optional[List[str]] = None
    scan_results: Optional[Dict[str, Any]] = None
    llm_analysis: Optional[str] = None
    suggestions: Optional[List[str]] = None

class EnhancedChatAssistant:
    """Enhanced Chat Assistant v·ªõi Scan Orchestrator"""
    
    def __init__(self):
        self.llm_client = GeminiClient()
        self.rag_retriever = EnhancedRAGRetriever()
        self.scan_orchestrator = ScanOrchestrator()
        self.evidence_storage = EvidenceStorage()
        self.conversation_history = []
    
    async def process_message(self, user_message: str, user_id: str = "default") -> ChatResponse:
        """X·ª≠ l√Ω tin nh·∫Øn t·ª´ ng∆∞·ªùi d√πng"""
        try:
            message = user_message.strip()
            command = self._detect_command(message)
            
            # Process based on command
            if command == ChatCommand.PAYLOAD:
                return await self._handle_payload_command(message)
            elif command == ChatCommand.SCAN:
                return await self._handle_scan_command(message)
            elif command == ChatCommand.SCAN_STATUS:
                return await self._handle_scan_status_command(message)
            elif command == ChatCommand.SCAN_RESULTS:
                return await self._handle_scan_results_command(message)
            elif command == ChatCommand.EVIDENCE:
                return await self._handle_evidence_command(message)
            elif command == ChatCommand.HELP:
                return await self._handle_help_command()
            elif command == ChatCommand.REPORT:
                return await self._handle_report_command(message)
            elif command == ChatCommand.RECOMMEND:
                return await self._handle_recommend_command(message)
            elif command == ChatCommand.GREETING:
                return await self._handle_greeting_command()
            else:
                return await self._handle_natural_conversation(message)
                
        except Exception as e:
            return ChatResponse(
                message=f"[ERROR] L·ªói: {str(e)}",
                command=ChatCommand.UNKNOWN,
                suggestions=["H√£y th·ª≠ l·∫°i", "S·ª≠ d·ª•ng /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n"]
            )
    
    def _detect_command(self, message: str) -> ChatCommand:
        """Detect command t·ª´ message"""
        message_lower = message.lower()
        
        if message_lower.startswith('/payload'):
            return ChatCommand.PAYLOAD
        elif message_lower.startswith('/scan-status'):
            return ChatCommand.SCAN_STATUS
        elif message_lower.startswith('/scan-results'):
            return ChatCommand.SCAN_RESULTS
        elif message_lower.startswith('/scan-cancel'):
            return ChatCommand.SCAN_CANCEL
        elif message_lower.startswith('/scan'):
            return ChatCommand.SCAN
        elif message_lower.startswith('/evidence'):
            return ChatCommand.EVIDENCE
        elif message_lower.startswith('/help'):
            return ChatCommand.HELP
        elif message_lower.startswith('/report'):
            return ChatCommand.REPORT
        elif message_lower.startswith('/recommend'):
            return ChatCommand.RECOMMEND
        elif message_lower.startswith('/') or message_lower in ['hi', 'hello', 'ch√†o', 'xin ch√†o']:
            return ChatCommand.GREETING
        else:
            return ChatCommand.UNKNOWN
    
    async def _handle_scan_command(self, message: str) -> ChatResponse:
        """X·ª≠ l√Ω l·ªánh /scan v·ªõi Enhanced Orchestrator System"""
        try:
            # Extract URL from message
            url_pattern = r'https?://[^\s]+'
            url_match = re.search(url_pattern, message)
            
            if not url_match:
                return ChatResponse(
                    message="[ERROR] Vui l√≤ng cung c·∫•p URL ƒë·ªÉ scan. V√≠ d·ª•: /scan http://example.com",
                    command=ChatCommand.SCAN,
                    suggestions=[
                        "S·ª≠ d·ª•ng: /scan http://testphp.vulnweb.com/",
                        "S·ª≠ d·ª•ng: /scan http://demo.testfire.net/",
                        "Xem h∆∞·ªõng d·∫´n: /help"
                    ]
                )
            
            target_url = url_match.group()
            
            # Start scan with orchestrator system
            result = await self.scan_orchestrator.start_scan(target_url)
            
            if result["success"]:
                job_id = result["job_id"]
                
                # Create response message with RAG importance
                response_message = f"""üöÄ **Enhanced Security Scan v·ªõi RAG Intelligence**

üéØ **Target:** `{target_url}`
üÜî **Job ID:** `{job_id}`
üß† **RAG Knowledge Base:** ‚úÖ Active
üìÅ **Evidence Storage:** ‚úÖ Enabled

üîÑ **Enhanced Scan Pipeline:**
1. üîç **Reconnaissance** - HTTPX, WhatWeb analysis
2. üï∑Ô∏è **Crawling** - GoSpider intelligent crawling  
3. üéØ **Fuzzing** - FFUF directory discovery
4. üõ°Ô∏è **Vulnerability Detection** - Nuclei, Dalfox, Nikto
5. ‚úÖ **Confirmatory Tests** - Marker reflection, evidence capture
6. ü§ñ **LLM + RAG Enrichment** - Provenance tracking
7. üìä **Evidence Storage** - Screenshots, HAR, raw outputs

‚ú® **RAG Intelligence Features:**
‚Ä¢ üìö OWASP Top 10 2023 knowledge
‚Ä¢ üéØ Advanced payload techniques  
‚Ä¢ üåç Real-world vulnerability patterns
‚Ä¢ üîß Best practice remediation
‚Ä¢ üóÑÔ∏è CVE database integration
‚Ä¢ üìã Provenance tracking for all claims

‚è≥ **Status:** Scan ƒëang ch·∫°y... S·ª≠ d·ª•ng `/scan-status` ƒë·ªÉ ki·ªÉm tra ti·∫øn ƒë·ªô.

üéØ **RAG Impact - Knowledge Base cung c·∫•p:**
‚Ä¢ Context ch√≠nh x√°c cho t·ª´ng lo·∫°i l·ªó h·ªïng
‚Ä¢ Advanced detection techniques
‚Ä¢ Comprehensive remediation guidance  
‚Ä¢ Real-world attack patterns
‚Ä¢ Industry best practices
‚Ä¢ Evidence-based analysis

üí° **Next Steps:**
‚Ä¢ Ki·ªÉm tra ti·∫øn ƒë·ªô: `/scan-status {job_id}`
‚Ä¢ Xem k·∫øt qu·∫£: `/scan-results {job_id}`
‚Ä¢ T·∫£i evidence: `/evidence {job_id}`
‚Ä¢ T·∫°o b√°o c√°o: `/report {job_id}`"""
                
                return ChatResponse(
                    message=response_message,
                    command=ChatCommand.SCAN,
                    target_url=target_url,
                    suggestions=[
                        f"Ki·ªÉm tra ti·∫øn ƒë·ªô: /scan-status {job_id}",
                        f"Xem k·∫øt qu·∫£: /scan-results {job_id}",
                        f"T·∫£i evidence: /evidence {job_id}",
                        "T·∫°o payload: /payload xss " + target_url
                    ]
                )
            else:
                return ChatResponse(
                    message=f"[ERROR] Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu scan: {result.get('error', 'Unknown error')}",
                    command=ChatCommand.SCAN,
                    suggestions=[
                        "Ki·ªÉm tra URL c√≥ h·ª£p l·ªá kh√¥ng",
                        "Ki·ªÉm tra target c√≥ trong allowlist kh√¥ng",
                        "S·ª≠ d·ª•ng /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n"
                    ]
                )
            
        except Exception as e:
            return ChatResponse(
                message=f"[ERROR] L·ªói khi b·∫Øt ƒë·∫ßu scan: {str(e)}",
                command=ChatCommand.SCAN,
                suggestions=[
                    "Ki·ªÉm tra URL c√≥ h·ª£p l·ªá kh√¥ng",
                    "Th·ª≠ l·∫°i sau v√†i gi√¢y",
                    "S·ª≠ d·ª•ng /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n"
                ]
            )
    
    async def _handle_scan_status_command(self, message: str) -> ChatResponse:
        """X·ª≠ l√Ω l·ªánh /scan-status"""
        try:
            parts = message.split()
            if len(parts) < 2:
                return ChatResponse(
                    message="[ERROR] Vui l√≤ng cung c·∫•p Job ID. V√≠ d·ª•: /scan-status job_12345678",
                    command=ChatCommand.SCAN_STATUS,
                    suggestions=[
                        "Cung c·∫•p Job ID h·ª£p l·ªá",
                        "V√≠ d·ª•: /scan-status job_12345678",
                        "S·ª≠ d·ª•ng /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n"
                    ]
                )
            
            job_id = parts[1]
            job = self.scan_orchestrator.get_scan_status(job_id)
            
            if not job:
                return ChatResponse(
                    message=f"[ERROR] Kh√¥ng t√¨m th·∫•y job v·ªõi ID: {job_id}",
                    command=ChatCommand.SCAN_STATUS,
                    suggestions=[
                        "Ki·ªÉm tra Job ID",
                        "Xem danh s√°ch jobs: /jobs",
                        "B·∫Øt ƒë·∫ßu scan m·ªõi: /scan <URL>"
                    ]
                )
            
            # Create status message
            status_emoji = {
                "pending": "‚è≥",
                "running": "üîÑ",
                "completed": "‚úÖ",
                "failed": "‚ùå",
                "cancelled": "üö´"
            }
            
            emoji = status_emoji.get(job.status.value, "‚ùì")
            
            response_message = f"""{emoji} **Scan Status**

üÜî **Job ID:** `{job.job_id}`
üéØ **Target:** `{job.target_url}`
üìä **Status:** {job.status.value.upper()}
üîÑ **Stage:** {job.current_stage.value.replace('_', ' ').title()}
üìà **Progress:** {job.progress}%

‚è∞ **Timestamps:**
‚Ä¢ Created: {job.created_at}
‚Ä¢ Started: {job.started_at or 'Not started'}
‚Ä¢ Completed: {job.completed_at or 'Not completed'}

{f"‚ùå **Error:** {job.error_message}" if job.error_message else ""}

üí° **Next Steps:**
{f"‚Ä¢ Xem k·∫øt qu·∫£: /scan-results {job_id}" if job.status.value == "completed" else ""}
{f"‚Ä¢ H·ªßy scan: /scan-cancel {job_id}" if job.status.value == "running" else ""}
‚Ä¢ T·∫°o scan m·ªõi: /scan <URL>"""
            
            return ChatResponse(
                message=response_message,
                command=ChatCommand.SCAN_STATUS,
                suggestions=[
                    f"Xem k·∫øt qu·∫£: /scan-results {job_id}" if job.status.value == "completed" else f"Ki·ªÉm tra l·∫°i: /scan-status {job_id}",
                    "T·∫°o scan m·ªõi: /scan <URL>",
                    "Xem help: /help"
                ]
            )
            
        except Exception as e:
            return ChatResponse(
                message=f"[ERROR] L·ªói ki·ªÉm tra status: {str(e)}",
                command=ChatCommand.SCAN_STATUS,
                suggestions=[
                    "Ki·ªÉm tra Job ID",
                    "Th·ª≠ l·∫°i sau",
                    "S·ª≠ d·ª•ng /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n"
                ]
            )
    
    async def _handle_scan_results_command(self, message: str) -> ChatResponse:
        """X·ª≠ l√Ω l·ªánh /scan-results"""
        try:
            parts = message.split()
            if len(parts) < 2:
                return ChatResponse(
                    message="[ERROR] Vui l√≤ng cung c·∫•p Job ID. V√≠ d·ª•: /scan-results job_12345678",
                    command=ChatCommand.SCAN_RESULTS,
                    suggestions=[
                        "Cung c·∫•p Job ID h·ª£p l·ªá",
                        "V√≠ d·ª•: /scan-results job_12345678",
                        "S·ª≠ d·ª•ng /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n"
                    ]
                )
            
            job_id = parts[1]
            results = self.scan_orchestrator.get_scan_results(job_id)
            
            if not results:
                return ChatResponse(
                    message=f"[ERROR] Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ cho Job ID: {job_id}",
                    command=ChatCommand.SCAN_RESULTS,
                    suggestions=[
                        "Ki·ªÉm tra Job ID",
                        "Ki·ªÉm tra status: /scan-status {job_id}",
                        "B·∫Øt ƒë·∫ßu scan m·ªõi: /scan <URL>"
                    ]
                )
            
            findings = results.get("findings", [])
            
            # Create results summary
            severity_counts = {}
            for finding in findings:
                severity = finding.get("severity", "Unknown")
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            severity_emojis = {
                "Critical": "üî¥",
                "High": "üü†", 
                "Medium": "üü°",
                "Low": "üü¢",
                "Unknown": "‚ö™"
            }
            
            severity_summary = " | ".join([
                f"{severity_emojis.get(sev, '‚ö™')} {sev}: {count}" 
                for sev, count in severity_counts.items()
            ])
            
            response_message = f"""üìä **Scan Results**

üÜî **Job ID:** `{job_id}`
üéØ **Target:** `{results.get('target_url', '')}`
üìä **Status:** {results.get('status', '').upper()}
üìà **Progress:** {results.get('progress', 0)}%

üö® **Findings Summary:**
{severity_summary}
**Total:** {len(findings)} findings

üìÅ **Evidence Available:**
‚Ä¢ Raw outputs: {len(results.get('raw_outputs', {}))} files
‚Ä¢ Evidence directory: `{results.get('evidence_dir', '')}`

üß† **RAG-Enhanced Analysis:**
‚Ä¢ All findings enriched with RAG knowledge
‚Ä¢ Provenance tracking for all claims
‚Ä¢ Evidence-based confidence scoring
‚Ä¢ Industry-standard remediation

üí° **Next Steps:**
‚Ä¢ T·∫£i evidence: `/evidence {job_id}`
‚Ä¢ T·∫°o b√°o c√°o: `/report {job_id}`
‚Ä¢ Xem chi ti·∫øt: `/scan-results {job_id} detailed`"""
            
            return ChatResponse(
                message=response_message,
                command=ChatCommand.SCAN_RESULTS,
                suggestions=[
                    f"T·∫£i evidence: /evidence {job_id}",
                    f"T·∫°o b√°o c√°o: /report {job_id}",
                    "T·∫°o scan m·ªõi: /scan <URL>"
                ]
            )
            
        except Exception as e:
            return ChatResponse(
                message=f"[ERROR] L·ªói l·∫•y k·∫øt qu·∫£: {str(e)}",
                command=ChatCommand.SCAN_RESULTS,
                suggestions=[
                    "Ki·ªÉm tra Job ID",
                    "Th·ª≠ l·∫°i sau",
                    "S·ª≠ d·ª•ng /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n"
                ]
            )
    
    async def _handle_evidence_command(self, message: str) -> ChatResponse:
        """X·ª≠ l√Ω l·ªánh /evidence"""
        try:
            parts = message.split()
            if len(parts) < 2:
                return ChatResponse(
                    message="""üìÅ **Evidence Management**

üéØ **C√°ch s·ª≠ d·ª•ng:**
‚Ä¢ `/evidence <job_id>` - Li·ªát k√™ evidence files
‚Ä¢ `/evidence <job_id> <filename>` - T·∫£i specific file
‚Ä¢ `/evidence <job_id> archive` - T·∫£i evidence archive

üìã **V√≠ d·ª•:**
‚Ä¢ `/evidence job_12345678`
‚Ä¢ `/evidence job_12345678 nuclei.json`
‚Ä¢ `/evidence job_12345678 archive`

üí° **Evidence Types:**
‚Ä¢ Raw tool outputs (JSON)
‚Ä¢ Screenshots (PNG)
‚Ä¢ HAR files (Network traffic)
‚Ä¢ Request/Response data
‚Ä¢ Confirmatory test results""",
                    command=ChatCommand.EVIDENCE,
                    suggestions=[
                        "Li·ªát k√™ files: /evidence <job_id>",
                        "T·∫£i archive: /evidence <job_id> archive",
                        "Xem help: /help"
                    ]
                )
            
            job_id = parts[1]
            
            if len(parts) > 2 and parts[2] == "archive":
                # Download archive
                archive_path = self.evidence_storage.create_evidence_archive(job_id)
                if archive_path:
                    return ChatResponse(
                        message=f"üì¶ **Evidence Archive Ready**

üÜî **Job ID:** `{job_id}`
üìÅ **Archive:** `{archive_path}`
üìä **Size:** {os.path.getsize(archive_path) if os.path.exists(archive_path) else 0} bytes

üí° **Archive contains:**
‚Ä¢ All raw tool outputs
‚Ä¢ Screenshots and HAR files
‚Ä¢ Request/response data
‚Ä¢ Evidence index

üîó **Download:** Use API endpoint `/scan/evidence/{job_id}/archive`",
                        command=ChatCommand.EVIDENCE,
                        suggestions=[
                            f"Li·ªát k√™ files: /evidence {job_id}",
                            "T·∫°o b√°o c√°o: /report " + job_id,
                            "Xem k·∫øt qu·∫£: /scan-results " + job_id
                        ]
                    )
                else:
                    return ChatResponse(
                        message=f"[ERROR] Kh√¥ng th·ªÉ t·∫°o archive cho Job ID: {job_id}",
                        command=ChatCommand.EVIDENCE,
                        suggestions=[
                            "Ki·ªÉm tra Job ID",
                            "Ki·ªÉm tra evidence files",
                            "Th·ª≠ l·∫°i sau"
                        ]
                    )
            else:
                # List evidence files
                files = self.evidence_storage.list_evidence_files(job_id)
                
                if not files:
                    return ChatResponse(
                        message=f"[ERROR] Kh√¥ng t√¨m th·∫•y evidence files cho Job ID: {job_id}",
                        command=ChatCommand.EVIDENCE,
                        suggestions=[
                            "Ki·ªÉm tra Job ID",
                            "Ki·ªÉm tra scan status",
                            "B·∫Øt ƒë·∫ßu scan m·ªõi: /scan <URL>"
                        ]
                    )
                
                # Categorize files
                raw_outputs = [f for f in files if f.endswith('.json')]
                screenshots = [f for f in files if f.endswith('.png')]
                har_files = [f for f in files if f.endswith('.har')]
                other_files = [f for f in files if not any(f.endswith(ext) for ext in ['.json', '.png', '.har'])]
                
                response_message = f"""üìÅ **Evidence Files**

üÜî **Job ID:** `{job_id}`
üìä **Total Files:** {len(files)}

üîß **Raw Tool Outputs:** {len(raw_outputs)}
{chr(10).join([f"‚Ä¢ {os.path.basename(f)}" for f in raw_outputs[:5]])}
{f"... and {len(raw_outputs) - 5} more" if len(raw_outputs) > 5 else ""}

üì∏ **Screenshots:** {len(screenshots)}
{chr(10).join([f"‚Ä¢ {os.path.basename(f)}" for f in screenshots[:3]])}
{f"... and {len(screenshots) - 3} more" if len(screenshots) > 3 else ""}

üåê **HAR Files:** {len(har_files)}
{chr(10).join([f"‚Ä¢ {os.path.basename(f)}" for f in har_files[:3]])}
{f"... and {len(har_files) - 3} more" if len(har_files) > 3 else ""}

üìÑ **Other Files:** {len(other_files)}
{chr(10).join([f"‚Ä¢ {os.path.basename(f)}" for f in other_files[:3]])}
{f"... and {len(other_files) - 3} more" if len(other_files) > 3 else ""}

üí° **Next Steps:**
‚Ä¢ T·∫£i archive: `/evidence {job_id} archive`
‚Ä¢ T·∫£i specific file: `/evidence {job_id} <filename>`
‚Ä¢ T·∫°o b√°o c√°o: `/report {job_id}`"""
                
                return ChatResponse(
                    message=response_message,
                    command=ChatCommand.EVIDENCE,
                    suggestions=[
                        f"T·∫£i archive: /evidence {job_id} archive",
                        f"T·∫£i file: /evidence {job_id} <filename>",
                        f"T·∫°o b√°o c√°o: /report {job_id}"
                    ]
                )
            
        except Exception as e:
            return ChatResponse(
                message=f"[ERROR] L·ªói qu·∫£n l√Ω evidence: {str(e)}",
                command=ChatCommand.EVIDENCE,
                suggestions=[
                    "Ki·ªÉm tra Job ID",
                    "Th·ª≠ l·∫°i sau",
                    "S·ª≠ d·ª•ng /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n"
                ]
            )
    
    async def _handle_help_command(self) -> ChatResponse:
        """X·ª≠ l√Ω l·ªánh /help"""
        help_message = """üìö **Enhanced Security Assistant - H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng**

## üöÄ **L·ªánh Scan Chuy√™n Nghi·ªáp**
‚Ä¢ `/scan <URL>` - B·∫Øt ƒë·∫ßu enhanced scan v·ªõi RAG intelligence
‚Ä¢ `/scan-status <job_id>` - Ki·ªÉm tra tr·∫°ng th√°i scan job
‚Ä¢ `/scan-results <job_id>` - Xem k·∫øt qu·∫£ scan chi ti·∫øt
‚Ä¢ `/evidence <job_id>` - Qu·∫£n l√Ω evidence files
‚Ä¢ `/scan-cancel <job_id>` - H·ªßy scan job ƒëang ch·∫°y

## üéØ **L·ªánh Payload**
‚Ä¢ `/payload <type> <URL>` - T·∫°o payload cho vulnerability type
  - Types: xss, sql_injection, misconfig, idor
  - V√≠ d·ª•: `/payload xss http://testphp.vulnweb.com`

## üìä **L·ªánh B√°o c√°o**
‚Ä¢ `/report <job_id>` - T·∫°o b√°o c√°o chuy√™n nghi·ªáp
‚Ä¢ `/recommend <vulnerability_type>` - Khuy·∫øn ngh·ªã kh·∫Øc ph·ª•c

## üß† **RAG Intelligence Features**
‚Ä¢ üìö OWASP Top 10 2023 knowledge
‚Ä¢ üéØ Advanced payload techniques  
‚Ä¢ üåç Real-world vulnerability patterns
‚Ä¢ üîß Best practice remediation
‚Ä¢ üóÑÔ∏è CVE database integration
‚Ä¢ üìã Provenance tracking for all claims

## üîÑ **Enhanced Scan Pipeline**
1. **Reconnaissance** - HTTPX, WhatWeb analysis
2. **Crawling** - GoSpider intelligent crawling  
3. **Fuzzing** - FFUF directory discovery
4. **Vulnerability Detection** - Nuclei, Dalfox, Nikto
5. **Confirmatory Tests** - Marker reflection, evidence capture
6. **LLM + RAG Enrichment** - Provenance tracking
7. **Evidence Storage** - Screenshots, HAR, raw outputs

## üí° **V√≠ d·ª• s·ª≠ d·ª•ng**
1. **Scan chuy√™n nghi·ªáp:**
   `/scan http://testphp.vulnweb.com`
   ‚Üí T·∫°o job v·ªõi ID, d√πng `/scan-status <job_id>` ƒë·ªÉ theo d√µi

2. **T·∫°o payload:**
   `/payload xss http://testphp.vulnweb.com`
   ‚Üí T·∫°o payload XSS ph√π h·ª£p v·ªõi target

3. **Qu·∫£n l√Ω evidence:**
   `/evidence job_12345678`
   ‚Üí Li·ªát k√™ v√† t·∫£i evidence files

## üõ°Ô∏è **B·∫£o m·∫≠t**
‚Ä¢ Ch·ªâ scan targets trong allowlist
‚Ä¢ T·∫•t c·∫£ tools ch·∫°y trong sandbox
‚Ä¢ Kh√¥ng th·ª±c hi·ªán destructive actions
‚Ä¢ Timeout v√† resource limits
‚Ä¢ Evidence storage v·ªõi provenance tracking

**S·ª≠ d·ª•ng `/help` ƒë·ªÉ xem l·∫°i h∆∞·ªõng d·∫´n n√†y!**"""
        
        return ChatResponse(
            message=help_message,
            command=ChatCommand.HELP,
            suggestions=[
                "B·∫Øt ƒë·∫ßu scan: /scan <URL>",
                "T·∫°o payload: /payload xss <URL>",
                "Xem evidence: /evidence <job_id>"
            ]
        )
    
    async def _handle_greeting_command(self) -> ChatResponse:
        """X·ª≠ l√Ω l·ªánh ch√†o h·ªèi"""
        greeting_message = """üëã **Ch√†o m·ª´ng ƒë·∫øn v·ªõi Enhanced Security Assistant!**

üöÄ **T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:**
‚Ä¢ üîç **Scan b·∫£o m·∫≠t** v·ªõi RAG intelligence
‚Ä¢ üéØ **T·∫°o payload** cho c√°c lo·∫°i l·ªó h·ªïng
‚Ä¢ üìä **T·∫°o b√°o c√°o** chuy√™n nghi·ªáp
‚Ä¢ üõ†Ô∏è **Khuy·∫øn ngh·ªã kh·∫Øc ph·ª•c** d·ª±a tr√™n RAG knowledge

üß† **RAG Intelligence:**
‚Ä¢ üìö OWASP Top 10 2023 knowledge
‚Ä¢ üéØ Advanced payload techniques  
‚Ä¢ üåç Real-world vulnerability patterns
‚Ä¢ üîß Best practice remediation
‚Ä¢ üìã Provenance tracking for all claims

üí° **B·∫Øt ƒë·∫ßu ngay:**
‚Ä¢ `/scan http://testphp.vulnweb.com` - Scan b·∫£o m·∫≠t
‚Ä¢ `/payload xss http://example.com` - T·∫°o payload XSS
‚Ä¢ `/help` - Xem h∆∞·ªõng d·∫´n chi ti·∫øt

üéØ **T√≠nh nƒÉng n·ªïi b·∫≠t:**
‚Ä¢ Evidence-based analysis
‚Ä¢ Confirmatory testing
‚Ä¢ Screenshot capture
‚Ä¢ HAR file recording
‚Ä¢ Provenance tracking

**H√£y th·ª≠ m·ªôt l·ªánh ƒë·ªÉ b·∫Øt ƒë·∫ßu!**"""
        
        return ChatResponse(
            message=greeting_message,
            command=ChatCommand.GREETING,
            suggestions=[
                "B·∫Øt ƒë·∫ßu scan: /scan http://testphp.vulnweb.com",
                "T·∫°o payload: /payload xss <URL>",
                "Xem help: /help"
            ]
        )
    
    async def _handle_payload_command(self, message: str) -> ChatResponse:
        """X·ª≠ l√Ω l·ªánh /payload"""
        # Implementation t∆∞∆°ng t·ª± nh∆∞ tr∆∞·ªõc
        return ChatResponse(
            message="Payload command - Implementation pending",
            command=ChatCommand.PAYLOAD,
            suggestions=["Xem help: /help"]
        )
    
    async def _handle_report_command(self, message: str) -> ChatResponse:
        """X·ª≠ l√Ω l·ªánh /report"""
        # Implementation t∆∞∆°ng t·ª± nh∆∞ tr∆∞·ªõc
        return ChatResponse(
            message="Report command - Implementation pending",
            command=ChatCommand.REPORT,
            suggestions=["Xem help: /help"]
        )
    
    async def _handle_recommend_command(self, message: str) -> ChatResponse:
        """X·ª≠ l√Ω l·ªánh /recommend"""
        # Implementation t∆∞∆°ng t·ª± nh∆∞ tr∆∞·ªõc
        return ChatResponse(
            message="Recommend command - Implementation pending",
            command=ChatCommand.RECOMMEND,
            suggestions=["Xem help: /help"]
        )
    
    async def _handle_natural_conversation(self, message: str) -> ChatResponse:
        """X·ª≠ l√Ω conversation t·ª± nhi√™n"""
        # Implementation t∆∞∆°ng t·ª± nh∆∞ tr∆∞·ªõc
        return ChatResponse(
            message="Natural conversation - Implementation pending",
            command=ChatCommand.UNKNOWN,
            suggestions=["S·ª≠ d·ª•ng /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n"]
        )